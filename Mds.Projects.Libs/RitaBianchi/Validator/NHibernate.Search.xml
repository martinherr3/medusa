<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NHibernate.Search</name>
    </assembly>
    <members>
        <member name="T:NHibernate.Search.Attributes.AnalyzerAttribute">
            <summary>
            Defines an analyzer for a given entity, method or field 
            </summary>
        </member>
        <member name="T:NHibernate.Search.Attributes.BoostAttribute">
            <summary>
            Applies a boost factor on a field or whole entity
            </summary>
        </member>
        <member name="T:NHibernate.Search.Attributes.IndexedEmbeddedAttribute">
            <summary>
            Specifies that an association is to be indexed in the root entity index
            </summary>
        </member>
        <member name="T:NHibernate.Search.Backend.Impl.Lucene.LuceneBackendQueueProcessor">
            <summary>
            Apply the operations to Lucene directories avoiding deadlocks
            </summary>
        </member>
        <member name="M:NHibernate.Search.Backend.Impl.Lucene.LuceneBackendQueueProcessor.SortQueueToAvoidDeadLocks(System.Collections.Generic.List{NHibernate.Search.Backend.LuceneWork},NHibernate.Search.Backend.Workspace)">
            <summary>
            one must lock the directory providers in the exact same order to avoid
            dead lock between concurrent threads or processes
            To achieve that, the work will be done per directory provider
            We rely on the both the DocumentBuilder.GetHashCode() and the GetWorkHashCode() to 
            sort them by predictive order at all times, and to put deletes before adds
            </summary>
        </member>
        <member name="M:NHibernate.Search.Backend.Impl.Lucene.LuceneBackendQueueProcessor.Run(System.Object)">
            <summary>
            
            </summary>
            <param name="ignore">Ignored, used to keep the delegate signature that WaitCallback requires</param>
        </member>
        <member name="T:NHibernate.Search.Backend.IBackendQueueProcessorFactory">
            <summary>
            Build stateful backend processor
            Must have a no arg constructor
            The factory typically prepare or pool the resources needed by the queue processor
            </summary>
        </member>
        <member name="M:NHibernate.Search.Backend.IBackendQueueProcessorFactory.GetProcessor(System.Collections.Generic.List{NHibernate.Search.Backend.LuceneWork})">
            <summary>
            Return a runnable implementation responsible for processing the queue to a given backend
            </summary>
            <param name="queue"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Search.Backend.Impl.BatchedQueueingProcessor">
            <summary>
             Batch work until #ExecuteQueue is called.
             The work is then executed synchronously or asynchronously
            </summary>
        </member>
        <member name="T:NHibernate.Search.Backend.IQueueingProcessor">
            <summary>
             Pile work operations
             No thread safety has to be implemented, the queue being scoped already
             The implementation must be "stateless" wrt the queue through (ie not store the queue state)
            </summary>
        </member>
        <member name="M:NHibernate.Search.Backend.IQueueingProcessor.PerformWork(System.Collections.Generic.List{NHibernate.Search.Backend.LuceneWork})">
            <summary>
            Performs all the work in the queue
            </summary>
            <param name="queue">The queue.</param>
        </member>
        <member name="M:NHibernate.Search.Backend.IQueueingProcessor.CancelWork(System.Collections.Generic.List{NHibernate.Search.Backend.LuceneWork})">
            <summary>
            Rollback 
            </summary>
            <param name="queue"></param>
        </member>
        <member name="T:NHibernate.Search.Backend.Work">
            <summary>
            work unit. Only make sense inside the same session since it uses the scope principle
            </summary>
        </member>
        <member name="T:NHibernate.Search.Backend.Workspace">
            <summary>
            Lucene workspace
            This is not intended to be used in a multithreaded environment
            <p/>
            One cannot execute modification through an IndexReader when an IndexWriter has been acquired on the same underlying directory
            One cannot get an IndexWriter when an IndexReader have been acquired and modificed on the same underlying directory
            The recommended approach is to execute all the modifications on the IndexReaders, {@link #Dispose()} }, and acquire the
            index writers
            </summary>
        </member>
        <member name="M:NHibernate.Search.Backend.Workspace.Dispose">
            <summary>
            release resources consumed in the workspace if any
            </summary>
        </member>
        <member name="F:NHibernate.Search.Backend.WorkType.Purge">
            <summary>
            Used to remove a specific instance of a class from an index.
            </summary>
        </member>
        <member name="F:NHibernate.Search.Backend.WorkType.PurgeAll">
            <summary>
            Used to remove all instances of a class from an index.
            </summary>
        </member>
        <member name="F:NHibernate.Search.Backend.WorkType.Index">
            <summary>
            Used for batch indexing.
            </summary>
        </member>
        <member name="T:NHibernate.Search.Bridge.IStringBridge">
            <summary>
            Transform an object into a string representation
            </summary>
        </member>
        <member name="M:NHibernate.Search.Bridge.IStringBridge.ObjectToString(System.Object)">
            <summary>
            convert the object representation to a String
            The return String must not be null, it can be empty though</summary>
            <param name="?"></param>
        </member>
        <member name="M:NHibernate.Search.Bridge.ITwoWayStringBridge.StringToObject(System.String)">
            <summary>
            Convert the string representation to an object
            </summary>
        </member>
        <member name="T:NHibernate.Search.Bridge.IFieldBridge">
            <summary>
            Put an object inside the document.
            </summary>
        </member>
        <member name="T:NHibernate.Search.Engine.DocumentBuilder">
            <summary>
            Set up and provide a manager for indexes classes
            </summary>
        </member>
        <member name="M:NHibernate.Search.Engine.DocumentBuilder.AddToWorkQueue(System.Object,System.Object,NHibernate.Search.Backend.WorkType,System.Collections.Generic.List{NHibernate.Search.Backend.LuceneWork},NHibernate.Search.Engine.SearchFactory)">
            <summary>
            This add the new work to the queue, so it can be processed in a batch fashion later
            </summary>
        </member>
        <member name="F:NHibernate.Search.Engine.SearchFactory.lockableDirectoryProviders">
            <summary>
            Note that we will lock on the values in this dictionary
            </summary>
        </member>
        <member name="M:NHibernate.Search.IFullTextSession.Index(System.Object)">
            <summary>
            Force the (re)indexing of a given <b>managed</b> object.
            Indexation is batched per transaction</summary>
            <param name="entity"></param>
        </member>
        <member name="M:NHibernate.Search.IFullTextSession.Purge(System.Type,System.Object)">
            <summary>
            Purge the instance with the specified identity from the index, but not the database.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Search.IFullTextSession.PurgeAll(System.Type)">
            <summary>
            Purge all instances from the index, but not the database.
            </summary>
            <param name="clazz"></param>
        </member>
        <member name="M:NHibernate.Search.Query.FullTextQueryImpl.#ctor(Lucene.Net.Search.Query,System.Type[],NHibernate.ISession,NHibernate.Engine.Query.ParameterMetadata)">
            <summary>
            classes must be immutable
            </summary>
        </member>
        <member name="M:NHibernate.Search.Query.FullTextQueryImpl.Enumerable``1">
            <summary>
            Return an interator on the results.
            Retrieve the object one by one (initialize it during the next() operation)
            </summary>
        </member>
        <!-- El comentario XML con formato incorrecto se omite para el miembro "T:NHibernate.Search.Storage.FSMasterDirectoryProvider" -->
        <!-- El comentario XML con formato incorrecto se omite para el miembro "T:NHibernate.Search.Storage.FSSlaveDirectoryProvider" -->
        <member name="M:NHibernate.Search.DirectoryProviderHelper.GetSourceDirectory(System.String,System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Build a directory name out of a root and relative path, guessing the significant part
            and checking for the file availability
            </summary>
        </member>
    </members>
</doc>
